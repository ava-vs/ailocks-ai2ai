# План реализации Long-Polling для системы уведомлений

## 1. Контекст и цели

**Проблема:** Текущая реализация уведомлений на основе Server-Sent Events (SSE) в Edge-функции Netlify нестабильна из-за ограничений на использование npm-модулей. Это приводит к сбоям при сборке и развертывании.

**Цель:** Заменить SSE на надежную и проверенную long-polling архитектуру, используя `pg_notify` в PostgreSQL. Это обеспечит мгновенную доставку уведомлений, решит проблему с зависимостями и будет эффективно работать в рамках ограничений Netlify Functions.

## 2. Анализ архитектурных нюансов

1.  **База данных:** Основной драйвер Drizzle (`drizzle-orm/neon-http`) оптимизирован для короткоживущих HTTP-запросов и не поддерживает постоянные соединения, необходимые для `LISTEN`.
    *   **Решение:** В функции long-polling будет создан отдельный клиент с использованием `node-postgres` (`pg`), который способен поддерживать долгоживущее соединение для прослушивания событий.

2.  **Авторизация:** Система использует JWT в httpOnly cookie. Фронтенд отправляет cookie автоматически.
    *   **Решение:** Бэкенд-функция будет извлекать токен из cookie, верифицировать его и получать `userId` для создания уникального канала подписки.

3.  **Фронтенд:** Хук `useNotifications` должен быть полностью переписан.
    *   **Решение:** Вместо `EventSource` будет реализована рекурсивная функция `fetch`, которая непрерывно поддерживает один открытый long-polling запрос.

## 3. Пошаговый план реализации

### Шаг 1: Миграция базы данных (Backend)

-   [x] **Задача:** Создать SQL-миграцию для добавления триггера `AFTER INSERT` в таблицу `notifications`.
-   [x] **Реализация:** Триггер будет вызывать функцию `notify_new_notification()`, которая отправляет `pg_notify` в канал `new_notification_<userId>` с `json` полезной нагрузкой.
-   [x] **Файл:** `drizzle/0009_add_notification_trigger.sql`.
-   **Статус:** **Выполнено.**

### Шаг 2: Функция Long-Polling (Backend)

-   [x] **Задача:** Создать и отладить Netlify Function `notifications-long-poll.ts`.
-   [x] **Реализация:**
    1.  Импортировать `pg` для создания клиента с постоянным соединением.
    2.  При входящем запросе:
        *   Извлечь и верифицировать JWT из cookie.
        *   Подключиться к БД и выполнить `LISTEN new_notification_<userId>`.
        *   Ожидать `NOTIFY` в течение 25 секунд (безопасный лимит для Netlify).
    3.  **При получении `NOTIFY`:**
        *   Запросить из БД *все* непрочитанные уведомления для пользователя.
        *   Вернуть их с кодом `200 OK`.
    4.  **При таймауте:**
        *   Вернуть ответ с кодом `204 No Content`.
    5.  В блоке `finally` всегда выполнять `UNLISTEN` и закрывать соединение для избежания утечек.
-   [x] **Файл:** `netlify/functions/notifications-long-poll.ts`.
-   **Статус:** **Выполнено.**

### Шаг 3: Хук уведомлений (Frontend)

-   [x] **Задача:** Полностью переписать хук `useNotifications.ts`.
-   [x] **Реализация:**
    1.  Удалить всю логику, связанную с `EventSource` и `NotificationService`.
    2.  Создать атомы `nanostores` (`notificationsStore`, `unreadCountsStore`) и хелперы для управления состоянием (`addNotification`, `markAsReadInStore` и т.д.) прямо в этом файле.
    3.  Реализовать асинхронную рекурсивную функцию `poll()`:
        *   Использовать `AbortController` для отмены запроса при размонтировании компонента.
        *   Выполнять `fetch` к `/netlify/functions/notifications-long-poll`.
        *   При ответе `200 OK`, обновить `notificationsStore` и немедленно вызвать `poll()` снова.
        *   При ответе `204 No Content`, немедленно вызвать `poll()` снова.
        *   При ошибке сети, подождать 5 секунд (экспоненциальная задержка) и вызвать `poll()` снова.
    4.  В `useEffect` при монтировании компонента:
        *   Выполнить первоначальный `fetch` для загрузки всех уведомлений.
        *   Запустить первый вызов `poll()`.
-   [x] **Файл:** `src/hooks/useNotifications.ts`.
-   **Статус:** **Выполнено.**

### Шаг 4: Очистка проекта

-   [ ] **Задача:** Удалить неиспользуемые файлы после успешного внедрения long-polling.
-   [ ] **Файлы для удаления:**
    *   `netlify/edge-functions/notifications-sse.ts`
    *   `netlify/functions/notifications-sse.ts`
    *   `netlify/functions/ailock-events.ts`
    *   `src/lib/ailock/notification-service.ts` (его функционал будет в `useNotifications.ts`).
-   [ ] **Дополнительно:** Обновить TODO-список проекта, отметив задачи как выполненные.
-   [ ] **Дополнительно:** Обновить `netlify.toml` и удалить обработчик для `notifications-sse`.
-   [ ] **Дополнительно:** Обновить `docs/AI2AI_Network_ru.md` для отражения новой архитектуры уведомлений. 